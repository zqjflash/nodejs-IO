# nodejs-IO
异步I/O

## 为什么要异步I/O

> 在跨网络结构下，I/O具体到实处可以从用户体验和资源分配两方面说起。

  * 用户体验

    * 采用异步请求，在下载资源期间，JavaScript和UI的执行都不会处于等待状态，可以继续响应用户的交互行为。
    * 同步与异步时间消耗对比，前者时间为M+N，后者为max(M+N)
    * 同步代码如下：

	    ```js
	    // 消耗时间为M
	    getData('from_db');
	    // 消耗时间为N
	    getData('from_remote_api');
	    ```
    * 异步代码如下：
      ```js
      getData('from_db', function(result) {
        // 消费时间为M
      });
      getData('from_remote_api', function(result) {
        // 消费时间为N
      });
      ```
    __随着应用复杂性的增加，情景将会变成M+N+... 

    * 用图表对比看看CPU一级缓存到网络的数据访问所需要的开销，I/O是昂贵的，分布式I/O是更加昂贵
    
    __CPU时钟周期：通常为节拍脉冲或T周期，既主频的倒数，它是处理操作的最基本单位__

    <table>
        <tr><td>I/O类型</td><td>花费的CPU时钟周期</td></tr>
        <tr><td>CPU一级缓存</td><td>3</td></tr>
        <tr><td>CPU二级缓存</td><td>14</td></tr>
        <tr><td>内存</td><td>250</td></tr>
        <tr><td>硬盘</td><td>41000000</td></tr>
        <tr><td>网络</td><td>240000000</td></tr>
    </table>

  * 资源分配

    * 假设业务场景中有一组互不相关的任务需要完成，现行的主流方法有以下两种：

      * 单线程串行依次执行；
      * 多线程并行完成。

      __多线程的代价在于创建线程和执行期线程上下文切换的开销较大，在复杂的业务中，多线程编程经常面临锁、状态同步问题__

      __单线程顺序执行任务的方式比较符合编程人员按顺序思考的思维方式，缺点在于性能，任意一个略慢的任务都会导致后续执行代码被阻塞__

      __添加硬件资源是一种提升服务质量的方式，消耗物理资源大__

      * node在以上问题给了一套解决方案：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程原理阻塞，更好地使用CPU

      * 为了弥补单线程无法利用多核CPU的缺点，Node提供了类似前端浏览器中Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。

      * 异步I/O的提出是期望I/O调用不再阻塞后续运算，将原有等待I/O完成的这段时间分配给其余需要的业务去执行。

      * 图3-1为异步I/O的调用示意图

        ![Alt text](https://raw.githubusercontent.com/zqjflash/nodejs-IO/master/async_io.png)

## 异步I/O实现现状

  * 异步I/O与非阻塞I/O
  * 理想的非阻塞异步I/O
  * 现实的异步I/O

## Node的异步I/O

  * 事件循环
  * 观察者
  * 请求对象
  * 执行回调
  * 小结

## 非I/O的异步API

  * 定时器
  * process.nextTick()
  * setImmediate()

## 事件驱动与高性能服务器

## 总结

## 参考资源